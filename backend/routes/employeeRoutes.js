const express = require('express');
const Employee = require('../models/Employee');
const bcrypt = require('bcryptjs');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const router = express.Router();

// Ensure uploads directory exists
const uploadPath = path.join(__dirname, '..', 'uploads');
if (!fs.existsSync(uploadPath)) {
  fs.mkdirSync(uploadPath, { recursive: true });
}

// Configure multer for secure file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, uploadPath),
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname);
    cb(null, `${file.fieldname}-${Date.now()}${ext}`);
  }
});

const upload = multer({
  storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Only image files are allowed!'), false);
    }
  }
});

// POST - Register new employee (auto-ID version)
router.post('/add', upload.single('profileImage'), async (req, res) => {
  try {
    // Destructure required fields
    const { fullName, email, phone, username, password, companyName, role } = req.body;
    
    // Validate required fields
    if (!fullName || !email || !username || !password || !phone || !companyName || !role) {
      return res.status(400).json({ 
        success: false,
        error: 'Missing required fields' 
      });
    }

    // Check for existing employee
    const existingEmployee = await Employee.findOne({ $or: [{ email }, { username }] });
    if (existingEmployee) {
      return res.status(400).json({
        success: false,
        error: existingEmployee.email === email ? 'Email already exists' : 'Username taken'
      });
    }

    // Hash password securely
    const hashedPassword = await bcrypt.hash(password, 12);

    // Create employee (employeeId is auto-generated by schema)
    const newEmployee = new Employee({
      fullName,
      email,
      phone,
      username,
      password: hashedPassword,
      companyName,
      role,
      department: req.body.department || null,
      position: req.body.position || null,
      salary: req.body.salary || null,
      hireDate: req.body.hireDate || new Date(),
      profileImage: req.file?.filename
    });

    await newEmployee.save();

    // Remove sensitive data from response
    const employeeData = newEmployee.toObject();
    delete employeeData.password;
    delete employeeData.__v;

    return res.status(201).json({
      success: true,
      data: employeeData
    });

  } catch (err) {
    console.error('Registration Error:', err);
    
    // Special handling for duplicate key errors
    if (err.code === 11000) {
      return res.status(400).json({
        success: false,
        error: 'Duplicate value (email or username already exists)'
      });
    }

    // Handle validation errors
    if (err.name === 'ValidationError') {
      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: err.message
      });
    }

    // Generic error handler
    return res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});

// GET - List all employees (safe version)
router.get('/', async (req, res) => {
  try {
    const employees = await Employee.find({}, '-password -__v');
    res.json({
      success: true,
      count: employees.length,
      data: employees
    });
  } catch (err) {
    console.error('Fetch Error:', err);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch employees'
    });
  }
});

module.exports = router;